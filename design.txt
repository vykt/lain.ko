[NOTICE]:

This is the raw interface to the lainko module. You probably want to 
use the interface provided by liblain.


[INTERFACE]:

-< introduction

Lainko module creates a character device '/dev/lainmemu' and a sysfs 
class '/sys/class/lainko'. The major number identifying the lainmemu 
device is generated dynamically. To find out it's value, the attribute 
file '/sys/class/lainko/memu_major' exposes lainmemu's major number.

In the future, additional devices may be added to lainko to provide 
other features.


-< the lainmemu device

The lainmemu character device defines the following file operations:

- open()  - Generic open.
- close() - Generic close.
- seek()  - Seek in the memory of a target process.
- read()  - Read memory.
- write() - Write memory.
- ioctl() - Miscellaneous operations.

The following ioctl calls are defined:

- 1 : Open the target process.
- 2 : Close the target process.
- 3 : Get the size of the memory map.
- 4 : Get the memory map.


-< lainmemu file operations

The lainmemu device does not have to be shared. Each open call allocates 
private storage tied to that file descriptor. This means multiple 
processes can make use of the lainmemu device simultaneously. This also 
means a single process may open the device multiple times to operate on 
multiple devices simultaneously.

The seekI(), read(), and write() operations act on the memory of a 
target process. They should behave identically to operations performed 
on the '/proc/<pid>/mem' file.


-< lainmemu ioctl calls

All ioctl calls take as their argument a userspace pointer to an instance 
of 'struct ioct_arg'.

Before any operations on memory can be performed, a target process must 
be set. This is done by providing ioctl call #1 with the pid of the 
target inside `struct ioct_arg`. An opened process will become a zombie 
until it is closed. A target process can be explicitly closed with ioctl 
call #2, or by simply closing the lainmemu file descriptor.

Lainmemu can also produce a memory map of the target process. This is a 
two step process:

1) Call ioctl #3, which will return the current number of virtual memory
   areas in the target process, N. Due to concurrency, this number may 
   grow immediately.

2) Allocate a buffer to hold the memory map, store a pointer to it in 
   'struct ioctl_arg', and call ioctl #4. On return, your buffer will 
   contain an array of 'struct vm_entry', one for each virtual memory 
   area. If your buffer is too small to hold the map, you will receive an 
   incomplete map. As such, consider allocating a buffer that can hold 
   N + 10% 'vm_entry' structures.
